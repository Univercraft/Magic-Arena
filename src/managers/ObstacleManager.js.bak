import * as THREE from 'three';

export class ObstacleManager {
    constructor(scene, arenaSize = 50) {
        this.scene = scene;
        this.arenaSize = arenaSize;
        this.obstacles = [];
        this.obstacleData = []; // Pour les collisions
        this.animatedWalls = []; // Murs qui peuvent appara√Ætre/dispara√Ætre
        this.wallHeight = 3.5;
        this.wallThickness = 0.8;
        this.seed = Math.random();
        
        // Syst√®me de labyrinthe vivant
        this.isLiving = true; // Le labyrinthe est vivant
        this.changeInterval = 15000; // Changer la configuration toutes les 15 secondes
        this.lastChangeTime = Date.now();
        this.animationDuration = 2000; // Dur√©e de l'animation mont√©e/descente (2 secondes)
        
        this.generateMaze();
        console.log('üåø Labyrinthe VIVANT cr√©√© avec', this.obstacles.length, 'obstacles (seed:', this.seed.toFixed(4), ')');
    }

    // Fonction de hachage simple pour la g√©n√©ration pseudo-al√©atoire
    seededRandom(seed) {
        const x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
    }

    // G√©n√©rer un nouveau labyrinthe
    regenerate() {
        console.log('üîÑ R√©g√©n√©ration du labyrinthe...');
        
        // Supprimer tous les obstacles existants
        this.obstacles.forEach(obstacle => {
            this.scene.remove(obstacle);
            if (obstacle.geometry) obstacle.geometry.dispose();
            if (obstacle.material) obstacle.material.dispose();
        });
        
        this.obstacles = [];
        this.obstacleData = [];
        
        // Nouvelle graine
        this.seed = Math.random();
        
        // G√©n√©rer le nouveau labyrinthe
        this.generateMaze();
        
        console.log('‚úÖ Nouveau labyrinthe g√©n√©r√© avec', this.obstacles.length, 'obstacles (seed:', this.seed.toFixed(4), ')');
    }

    generateMaze() {
        // Nettoyer les murs anim√©s existants
        this.animatedWalls = [];
        
        let seedCounter = this.seed * 1000;
        
        // Cr√©er des positions potentielles pour les murs
        const wallPositions = [];
        const numPotentialWalls = 30; // Plus de positions que de murs actifs
        
        for (let i = 0; i < numPotentialWalls; i++) {
            const isHorizontal = this.seededRandom(seedCounter++) > 0.5;
            const length = 3 + Math.floor(this.seededRandom(seedCounter++) * 5);
            
            let x, z;
            let attempts = 0;
            do {
                x = (this.seededRandom(seedCounter++) - 0.5) * (this.arenaSize - 15);
                z = (this.seededRandom(seedCounter++) - 0.5) * (this.arenaSize - 15);
                attempts++;
            } while (Math.abs(x) < 5 && Math.abs(z) < 5 && attempts < 10);
            
            wallPositions.push({
                x, z,
                width: isHorizontal ? length : this.wallThickness,
                depth: isHorizontal ? this.wallThickness : length,
                isActive: i < 15 // Seulement 15 murs actifs au d√©part
            });
        }
        
        // Cr√©er tous les murs (certains seront cach√©s sous terre)
        wallPositions.forEach((pos, index) => {
            this.createAnimatedHedge(pos.x, pos.z, pos.width, pos.depth, pos.isActive);
        });
        
        // Ajouter des arbres permanents (ne bougent pas)
        const numTrees = 8 + Math.floor(this.seededRandom(seedCounter++) * 8);
        for (let i = 0; i < numTrees; i++) {
            const angle = this.seededRandom(seedCounter++) * Math.PI * 2;
            const distance = 12 + this.seededRandom(seedCounter++) * 10;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            if (this.isPositionValidForTree({ x, z })) {
                this.createTree(x, z);
            }
        }
        
        // Ajouter des rochers permanents
        const numRocks = 6 + Math.floor(this.seededRandom(seedCounter++) * 6);
        for (let i = 0; i < numRocks; i++) {
            const angle = this.seededRandom(seedCounter++) * Math.PI * 2;
            const distance = 8 + this.seededRandom(seedCounter++) * 14;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            if (this.isPositionValidForTree({ x, z })) {
                this.createRock(x, z, this.seededRandom(seedCounter++));
            }
        }
    }

    isPositionValidForTree(position) {
        // √âviter le centre (spawn du joueur)
        if (Math.abs(position.x) < 6 && Math.abs(position.z) < 6) {
            return false;
        }
        
        // V√©rifier qu'il n'y a pas d'autres obstacles trop proches
        for (const obstacle of this.obstacleData) {
            const dx = position.x - obstacle.x;
            const dz = position.z - obstacle.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance < 4) { // Minimum 4 unit√©s entre les obstacles
                return false;
            }
        }
        
        return true;
    }

    createAnimatedHedge(x, z, width, depth, isActive = true) {
        // Mat√©riaux
        const hedgeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a4d1a,
            roughness: 0.9,
            metalness: 0.1
        });
        
        const topMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2d5a2d,
            roughness: 0.8
        });

        // Corps principal
        const geometry = new THREE.BoxGeometry(width, this.wallHeight, depth);
        const hedge = new THREE.Mesh(geometry, hedgeMaterial);
        hedge.castShadow = true;
        hedge.receiveShadow = true;
        
        // Sommet
        const topGeometry = new THREE.BoxGeometry(width, 0.3, depth);
        const top = new THREE.Mesh(topGeometry, topMaterial);
        top.castShadow = true;
        
        // Feuillage
        const foliageObjects = [];
        const foliageCount = Math.floor((width + depth) / 3);
        const foliageMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2d5a2d,
            roughness: 1
        });

        for (let i = 0; i < foliageCount; i++) {
            const offsetX = (Math.random() - 0.5) * width * 0.9;
            const offsetZ = (Math.random() - 0.5) * depth * 0.9;
            const offsetY = Math.random() * this.wallHeight * 0.5 + this.wallHeight * 0.5;

            const foliageGeometry = new THREE.SphereGeometry(0.25, 6, 6);
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.set(offsetX, offsetY, offsetZ);
            foliageObjects.push(foliage);
        }
        
        // Groupe pour l'animation
        const wallGroup = new THREE.Group();
        wallGroup.add(hedge);
        wallGroup.add(top);
        foliageObjects.forEach(f => wallGroup.add(f));
        
        // Position initiale
        const targetY = this.wallHeight / 2;
        const hiddenY = -this.wallHeight; // Sous le sol
        
        wallGroup.position.set(x, isActive ? targetY : hiddenY, z);
        this.scene.add(wallGroup);
        
        // Cr√©er l'objet anim√©
        const animatedWall = {
            group: wallGroup,
            hedge: hedge,
            top: top,
            foliage: foliageObjects,
            x: x,
            z: z,
            width: width,
            depth: depth,
            isActive: isActive,
            isAnimating: false,
            animationStartTime: 0,
            startY: isActive ? targetY : hiddenY,
            targetY: isActive ? targetY : hiddenY,
            collisionData: null // Sera cr√©√© quand le mur est actif
        };
        
        this.animatedWalls.push(animatedWall);
        this.obstacles.push(wallGroup);
        
        // Ajouter aux donn√©es de collision si actif
        if (isActive) {
            animatedWall.collisionData = {
                x: x,
                z: z,
                width: width,
                depth: depth,
                type: 'hedge',
                wall: animatedWall
            };
            this.obstacleData.push(animatedWall.collisionData);
        }
        
        // Repositionner les objets dans le groupe
        hedge.position.y = 0;
        top.position.y = this.wallHeight / 2 + 0.15;
        
        return animatedWall;
    }

    // Animer un mur pour qu'il monte ou descende
    animateWall(wall, shouldRise) {
        if (wall.isAnimating) return; // D√©j√† en animation
        
        wall.isAnimating = true;
        wall.animationStartTime = Date.now();
        wall.startY = wall.group.position.y;
        wall.targetY = shouldRise ? this.wallHeight / 2 : -this.wallHeight;
        
        // Si le mur monte, ajouter la collision imm√©diatement
        if (shouldRise && !wall.collisionData) {
            wall.collisionData = {
                x: wall.x,
                z: wall.z,
                width: wall.width,
                depth: wall.depth,
                type: 'hedge',
                wall: wall
            };
            this.obstacleData.push(wall.collisionData);
        }
        
        // Si le mur descend, retirer la collision apr√®s l'animation
        if (!shouldRise && wall.collisionData) {
            setTimeout(() => {
                const index = this.obstacleData.indexOf(wall.collisionData);
                if (index > -1) {
                    this.obstacleData.splice(index, 1);
                }
                wall.collisionData = null;
            }, this.animationDuration);
        }
        
        wall.isActive = shouldRise;
        
        // Effet visuel de particules
        this.createWallParticles(wall.x, wall.z, shouldRise);
    }

    // Cr√©er des particules lors de l'apparition/disparition d'un mur
    createWallParticles(x, z, isRising) {
        const particleCount = 20;
        const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
        const particleMaterial = new THREE.MeshBasicMaterial({ 
            color: isRising ? 0x4CAF50 : 0x8B4513,
            transparent: true,
            opacity: 0.8
        });

        for (let i = 0; i < particleCount; i++) {
            const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
            particle.position.set(
                x + (Math.random() - 0.5) * 2,
                0,
                z + (Math.random() - 0.5) * 2
            );
            
            this.scene.add(particle);
            
            // Animer la particule
            const startTime = Date.now();
            const duration = 1000;
            const velocity = {
                x: (Math.random() - 0.5) * 2,
                y: Math.random() * 3 + 1,
                z: (Math.random() - 0.5) * 2
            };
            
            const animateParticle = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress < 1) {
                    particle.position.x += velocity.x * 0.016;
                    particle.position.y += velocity.y * 0.016;
                    particle.position.z += velocity.z * 0.016;
                    velocity.y -= 9.8 * 0.016; // Gravit√©
                    
                    particle.material.opacity = 0.8 * (1 - progress);
                    
                    requestAnimationFrame(animateParticle);
                } else {
                    this.scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                }
            };
            
            animateParticle();
        }
    }

    // Mise √† jour du labyrinthe (√† appeler dans la boucle de jeu)
    update() {
        const now = Date.now();
        
        // Animer les murs en mouvement
        this.animatedWalls.forEach(wall => {
            if (wall.isAnimating) {
                const elapsed = now - wall.animationStartTime;
                const progress = Math.min(elapsed / this.animationDuration, 1);
                
                // Courbe d'animation ease-in-out
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                wall.group.position.y = wall.startY + (wall.targetY - wall.startY) * eased;
                
                if (progress >= 1) {
                    wall.isAnimating = false;
                    wall.group.position.y = wall.targetY;
                }
            }
        });
        
        // Changer la configuration du labyrinthe p√©riodiquement
        if (this.isLiving && now - this.lastChangeTime > this.changeInterval) {
            this.transformMaze();
            this.lastChangeTime = now;
        }
    }

    // Transformer le labyrinthe en faisant appara√Ætre/dispara√Ætre des murs
    transformMaze() {
        console.log('üåø Le labyrinthe se transforme...');
        
        // Choisir 3-5 murs √† faire changer d'√©tat
        const numChanges = 3 + Math.floor(Math.random() * 3);
        const shuffled = [...this.animatedWalls].sort(() => Math.random() - 0.5);
        
        for (let i = 0; i < Math.min(numChanges, shuffled.length); i++) {
            const wall = shuffled[i];
            if (!wall.isAnimating) {
                // Inverser l'√©tat du mur
                this.animateWall(wall, !wall.isActive);
            }
        }
    }

    createTree(x, z) {
        // Tronc
        const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.5, 4, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3d2817,
            roughness: 0.9
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.set(x, 2, z);
        trunk.castShadow = true;
        trunk.receiveShadow = true;
        this.scene.add(trunk);
        this.obstacles.push(trunk);

        // Feuillage
        const foliageGeometry = new THREE.SphereGeometry(1.5, 8, 8);
        const foliageMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a4d1a,
            roughness: 0.9
        });
        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
        foliage.position.set(x, 4.5, z);
        foliage.castShadow = true;
        this.scene.add(foliage);
        this.obstacles.push(foliage);

        // Collision
        this.obstacleData.push({
            x: x,
            z: z,
            radius: 1.5,
            type: 'tree'
        });
    }

    createRock(x, z, randomSeed) {
        // Rocher de taille variable
        const scale = 0.8 + randomSeed * 0.6; // 0.8 - 1.4
        const rockGeometry = new THREE.DodecahedronGeometry(scale, 0);
        const rockMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4a4a4a,
            roughness: 0.95,
            metalness: 0.05
        });
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(x, scale * 0.5, z);
        rock.rotation.y = randomSeed * Math.PI * 2;
        rock.castShadow = true;
        rock.receiveShadow = true;
        this.scene.add(rock);
        this.obstacles.push(rock);

        // Collision circulaire
        this.obstacleData.push({
            x: x,
            z: z,
            radius: scale * 1.2,
            type: 'rock'
        });
    }

    // V√©rifier si une position est valide (pas dans un obstacle)
    isPositionValid(position, margin = 1) {
        for (const obstacle of this.obstacleData) {
            if (obstacle.type === 'hedge') {
                // Collision avec une haie (rectangle)
                const halfWidth = obstacle.width / 2 + margin;
                const halfDepth = obstacle.depth / 2 + margin;
                
                if (position.x >= obstacle.x - halfWidth &&
                    position.x <= obstacle.x + halfWidth &&
                    position.z >= obstacle.z - halfDepth &&
                    position.z <= obstacle.z + halfDepth) {
                    return false;
                }
            } else if (obstacle.type === 'tree' || obstacle.type === 'rock') {
                // Collision avec un arbre ou rocher (cercle)
                const dx = position.x - obstacle.x;
                const dz = position.z - obstacle.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < obstacle.radius + margin) {
                    return false;
                }
            }
        }
        return true;
    }

    // V√©rifier la collision et corriger la position si n√©cessaire
    checkCollision(position, radius = 0.5) {
        let correctedPosition = position.clone();
        let collided = false;

        for (const obstacle of this.obstacleData) {
            if (obstacle.type === 'hedge') {
                // Collision avec une haie (rectangle)
                const halfWidth = obstacle.width / 2 + radius;
                const halfDepth = obstacle.depth / 2 + radius;
                
                // V√©rifier si on est dans la zone de collision
                if (position.x >= obstacle.x - halfWidth &&
                    position.x <= obstacle.x + halfWidth &&
                    position.z >= obstacle.z - halfDepth &&
                    position.z <= obstacle.z + halfDepth) {
                    
                    collided = true;
                    
                    // Calculer la position la plus proche en dehors de l'obstacle
                    const dx = position.x - obstacle.x;
                    const dz = position.z - obstacle.z;
                    
                    const overlapX = halfWidth - Math.abs(dx);
                    const overlapZ = halfDepth - Math.abs(dz);
                    
                    // Pousser dans la direction avec le moins de chevauchement
                    if (overlapX < overlapZ) {
                        correctedPosition.x = obstacle.x + (dx > 0 ? halfWidth : -halfWidth);
                    } else {
                        correctedPosition.z = obstacle.z + (dz > 0 ? halfDepth : -halfDepth);
                    }
                }
            } else if (obstacle.type === 'tree' || obstacle.type === 'rock') {
                // Collision avec un arbre ou rocher (cercle)
                const dx = position.x - obstacle.x;
                const dz = position.z - obstacle.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const minDistance = obstacle.radius + radius;
                
                if (distance < minDistance) {
                    collided = true;
                    
                    // Pousser √† l'ext√©rieur du cercle
                    const angle = Math.atan2(dz, dx);
                    correctedPosition.x = obstacle.x + Math.cos(angle) * minDistance;
                    correctedPosition.z = obstacle.z + Math.sin(angle) * minDistance;
                }
            }
        }

        return { position: correctedPosition, collided: collided };
    }

    // G√©n√©rer une position valide al√©atoire (pour le spawn de potions/sorts)
    getRandomValidPosition(minDistance = 5, maxDistance = 20, maxAttempts = 50) {
        for (let i = 0; i < maxAttempts; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = minDistance + Math.random() * (maxDistance - minDistance);
            
            const position = new THREE.Vector3(
                Math.cos(angle) * distance,
                0.3,
                Math.sin(angle) * distance
            );

            // V√©rifier que la position est valide
            if (this.isPositionValid(position, 1.5)) {
                return position;
            }
        }
        
        // Si on ne trouve pas de position, retourner une position par d√©faut
        console.warn('‚ö†Ô∏è Impossible de trouver une position valide, utilisation d\'une position par d√©faut');
        return new THREE.Vector3(0, 0.3, 0);
    }

    // G√©n√©rer une position valide pour le boss (plus loin du joueur)
    getRandomBossPosition(playerPosition, minDistance = 15, maxDistance = 22) {
        return this.getRandomValidPosition(minDistance, maxDistance);
    }
}
